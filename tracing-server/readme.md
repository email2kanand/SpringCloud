Distributed tracing:
-----------------------
#Zipkin server setup:
It helps gather timing data needed to troubleshoot latency problems in microservice architectures. Has a management console that helps to visualize time statistics generated by various microservices. It supports various back-ends where the span details can be saved. Currently it stores the span details in-memory by default but can be configured to store in Elastic search.

WHY: 
---------------
Distributed tracing systems provide detailed information about subsystem latency. It uses Zipkin. It supports retrieving Span information from various storage systems. Currently it supports In-memory and Elastic-search. 
As we understood sleuth will be managing trace and spanid. That needs to be store so that zipkin UI-can fetch the details from there and show.
To store this we have option of in-memory and ES.
Receiving Spans via Http is not efficient as that would make Zipkin single point of failure. So scalable option would be to read spans from Kafka and persist those in ES. 
Provision is provided to read Span details from Kafka and push to ES based on the configuration. Also, support has been added to receive spans via Http but store them in Elastic search without Kafka. 


Add:
--------------

<!-- this will handle tracer  -->
<dependency>
    <groupId>io.zipkin.java</groupId>
    <artifactId>zipkin-server</artifactId>
    <version>2.11.7</version>
</dependency>

<dependency>
    <groupId>io.zipkin.java</groupId>
    <artifactId>zipkin-autoconfigure-ui</artifactId>
    <version>2.11.7</version>
</dependency>



Annotate with @EnableZipkinServer or @EnableZipkinStream

Zipkin is a Spring-Boot-based project, the @EnableZipkinServer is not a
 Spring Cloud annotation. It’s an annotation that’spart of the Zipkin project. 
 This often confuses people who are new to the Spring Cloud Sleuth and Zipkin, 
 because the Spring Cloud team did write the @EnableZipkinStreamServer annotation
 as part of Spring Cloud Sleuth. The @EnableZipkinStreamServer annotation simplifies
the use of Zipkin with RabbitMQ and Kafka.

Advantages of @EnableZipkinServer is simplicity in setup. With the @EnableZipkinStream server you need to set up and configure the services being traced and the Zipkin server to publish/listen to RabbitMQ or Kafka for tracing data.The advantage of the @EnableZipkinStreamServer annotation is that you can continue to collect trace data even if the Zipkin server is unavailable. This is because the trace messages will accumulate the trace data on a message queue until the Zipkin server is available for processing the records. If you use the @EnableZipkinServer annotation and the Zipkin server is unavailable,the trace data that would have been sent by the service(s) to Zipkin will be lost.



Enable Kafka and Queue
--------------------------
To enable Kafka some useful properties:


#zipkin:
#    enabled: true  
#zipkin:
#  storage:
#    type: mem
# This will limit the number of spans and discard old ones.
#    mem:
#      max-spans: 200
# These properties indicate that Zipkin UI should read the spans from ES    
#   type: elasticsearch    
#   elasticsearch:
#       hosts: http://localhost:9300
#       index: zipkin
# These properties indicate that the spans need to be picked from Kafka topic
#  collector:
#     kafka:
#       zookeeper: localhost
#       topic: zipkin
#       group-id: zipkin


How to use ES
----------------
We can use ES also but should use with kafka. Bcoz it supports high throughput streamed data.
But if we store directly to ES that might be not able to consume if high throughput.
and also can scale like kafka.In real-time we might be having a no of microservices to store trace details.

Important Links
------------------
https://dev.to/dj_kev/how-to-set-up-distributed-tracing-in-microservices-with-spring-boot-zipkin-or-the-elk-stack-444a
https://dzone.com/articles/spring-cloud-sleuth-rabbitmq-zipkin-elasticsearch